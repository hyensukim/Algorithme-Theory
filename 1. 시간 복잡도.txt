* 알고리즘 선택의 기준이 되는 시간 복잡도.
- 시간복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다.
- 일반적으로 수행 시간은 1억번의 연산을 1초의 시간으로 간주하여 예측한다.

시간복잡도 유형
- 빅오메가 : 최선일 때의 연산 횟수를 나타내는 표기법(최소 연산)
- 빅세타 : 보통일 때의 연산횟수를 나타내는 표기법(평균 = n/2)
- *빅오 : 최악일 때의 연산횟수를 나타내는 표기법(n)

코딩테스트에서는 빅-오 표기법(O(n))을 기준으로 수행시간을 계산한다.
- 최악의 시간복잡도로 계산해야 모든 케이스의 통과가 가능하다.(최악의 상황까지 생각해야 그나마 긍정적인 결과가 나온다)

코딩테스트에서는 어떤 시간 복잡도 유형을 사용해야 하는가.
- O(1) : 제일 빠름.
- O(logn)
- O(n)
- O(nlogn)
- O(n²)
- O(2^n)
- O(n!) : 제일 느림.

대략 O 표기법에서는 상수만큼의 시간차이는 무시한다.
ex) O(2n+7)과 O(2n)은 대략적으로 동일하다.
즉, 계산 횟수에 붙은 상수는 별로 중요하지 않다는 것이다. 따라서 시간복잡도를 나타낼때 모든 상수는 떼어낸다.
7n + 1234, 1234567n, 모두 O(n)으로 나타낸다.
비슷한 이유로 3^n + 2n^3 + 1234n^2 + 33nlogn + 123456789번 계산하는 알고리즘의 시간복잡도는 O(3^n)이다.

연산횟수 계산방법
연산횟수 = 알고리즘 시간 복잡도 X 데이터의 크기.

시간복잡도 도출 기준
1. 상수는 시간 복잡도 계산에서 제외.
2. 가장 많이 중첩된 반복문의 횟수가 시간 복잡도의 기준이 된다.

코딩테스트
1. 알고리즘에 맞게 코딩 -> 시간초과
2. 이럴땐, 나의 로직을 확인.(비효율적인 로직 수정)